# iOS打包签名

为了保证安装到iOS设备上的app，都是经过苹果官方验证允许的，苹果建立了一套对iOS包体进行签名的机制。

## 签名的原理

为了了解签名的原理，我们需要先认识一下两种常见的加密类型

### 对称加密

对称加密指的是数据的发送方与数据的接收方各自持有**相同**的密钥，数据发送方使用密钥对数据进行加密，数据接受方收到数据后使用相同的密钥对数据进行解密，这种加密方式可以保证数据在传输过程中的安全性，即，截获数据的第三方无法解码出数据，无法篡改数据。但是，这种安全性是建立在密钥不被泄露的情况下，因此需要保证密钥在传输到数据接收者的过程中不被泄露。

### 非对称加密

与对称加密不同，非对称加密数据发送者与数据接受者各自持有不同的密钥，称为私钥与公钥。数据发送者持有私钥，发送数据前，使用私钥对数据进行加密。数据接受者收到数据后，使用公钥进行解密。私钥公钥成对出现，一个私钥有且仅有一个公钥与之对应，私钥保密，公钥则可以被任何人拥有。

看到这里，你也许会问，既然非对称加密的公钥谁都可以拥有，那数据传输的过程中，任何拥有公钥的第三方截取到数据之后不是能把数据看个精光，那还加密个屁啊。没错，确实是这样的，非对称加密理论上只是用来防止数据在传输过程中被篡改，至于数据在传输过程中被其他拥有公钥的第三方偷窥，不是对称加密关心的问题。

但是，单靠非对称加密真的能防止数据被篡改吗，并不能。设想一下这种情况。

1. 数据发送者A在本地生成了一对公钥与私钥，并把公钥发送给数据接收者B
2. 非数据接受者的第三方C拦截到了公钥，C自己在本地生成的一对新的私钥与公钥，并将这个公钥发送给了B，**B错误地将C的公钥当成了A的公钥。**
3. A使用私钥对数据进行加密，并发送给B
4. C对A发送的数据进行拦截，并使用A的公钥进行解密
5. C对解密后的数据进行篡改，并使用自己的私钥对篡改后的数据进行加密发送给了B
6. B收到数据后，使用C的公钥进行解密得到了经过C篡改的数据，**这不就寄了**

为了进一步降低非对称加密数据在传输过程被篡改的可能性，数据签名技术应运而生。

### 数据签名

数据签名看似高大上，实际上就是使用私钥对信息摘要进行加密得到的东西就叫做数据签名。数据签名验证信息可靠性的步骤如下：

1. 对收到的信息进行进行哈希计算得到摘要A
2. 对收到的数据签名使用公钥进行解密，得到摘要B
3. 判断A,B是否一样，一样说明信息没被篡改。

#### 信息摘要

以本文的主角iOS包体ipa为例，一个ipa包体的大小，小的有几十MB，大的动辄几GB，对这么大的数据量进行加密解密，耗时长，效率低。现代人都没什么耐心，有时候一个游戏首包资源太大都可能劝退一大群玩家。信息摘要解决的就是加密信息过大的问题，其是一段对未加密的信息内容进行哈希计算所得到的哈希值，具有以下几个特点：

1. 大小固定，不受原本信息大小的影响。
2. 不可逆，由信息摘要无法反推出原信息。
3. 唯一性，不同原数据生成的哈希值绝对不同。

必须说明，第3点应该说是理想的哈希算法的特点，当前常用的几种哈希算法，MD5,SHA-1,SHA-256,CRC32，都不是唯一性的，也就是不同数据是有可能得到一个相同的哈希值，网络上有一个解释是，哈希算法的输入空间可以说是无限的，但输出空间是有限的（哈希值大小固定）。至于第2点不可逆性的解释是，无论输入多么复杂，最终输出都是一个大小固定的值，说明中间丢失了很多信息，因此不可能从哈希值去复原原来的信息。但是，由于现有的哈希算法不能确保唯一性，因此，当两个输入的哈希值相等时，称为哈希碰撞。

哈希碰撞引出了哈希算法的另一个重要特性，防碰撞性。虽然无法从哈希值逆着推算出输入，也就是原信息，但是，如果我们能构造一个输入使得这个输入的哈希值是我们想要的那个呢，这样就能进行信息篡改了。目前，几种常用的哈希算法对比如下：

|特性|MD5|SHA-1|SHA-256|CRC-32|
|----|----|----|----|----|
|哈希值长度|128bits|160bits|256bits|32bits|
|安全性|较弱，已发现碰撞攻击|较弱，已发现理论碰撞攻击|目前较为安全|较弱，主要用于数据校验，不适用于安全场景|
|性能|最快|较快|最慢|最快|

### 签名证书

数字证书（Digital Certificate）是一种相当于现实世界中身份证的功能在数字领域中的实现。数字证书包含了个人或机构的身份信息及其公钥，因此也称为公钥证书。一份公钥证书图示如下：

![公钥证书](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/certificate.png?x-oss-process=image/resize,w_800)

接收方收到证书后，通过颁发该证书的CA公钥对证书进行签名验证，这里就有引出一个问题，怎么保证CA公钥的安全性呢？通常来说，包含CA公钥的证书由另一个更加权威的CA机构颁发，可以用颁发CA证书的CA机构的公钥进行验证，这里讲得有点绕，反正就是，证书验证证书。看到这里，你可能会问，这不是在套娃吗，没完没了的那种，验证一个证书需要另一个证书，验证另一个证书又要用另另一个证书。实际并不是这样，这个链条是有一个源头的，这个源头称为根证书，根证书就没有“验证根证书”这一说法了。根证书一般是随系统安装的，也就是根证书就在设备中，不需要通过网络传输，因此根证书一般都是可靠，安全的。比如，apple官网的support可以查到每一代iOS，iPadOS，macOS所安装的根证书（以及被apple拉黑的根证书机构，其中有一家中国机构，叫沃通，WoSign，这家机构跟360有些拉lam，笑死）。

#### iOS证书分类

iOS证书可以分为两类：

- Development：开发证书，用来开发合调试App。一般证书名是 iPhone Developer: xxx.
- Distrubution：发布证书，用来发布App。一般证书名是 iPhone Distribution: xxx.

打包时，根据打的是开发包，还是发布包，使用对应证书的私钥对包体进行签名。

#### iOS包体的验证与运行

在真机上运行测试包与正式包时，系统对两者的验证有所不同。

对于测试包，简单来说就是整个验证过程是在装包的设备上进行的。验证的过程如下图所示：

![开发包的验证](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/provisioning-profile-validation.png?x-oss-process=image/resize,w_800 "开发包体的验证")

开发包的.ips文件包括有：

1. App
2. Provisioning Profile
3. App文件的签名

对于正式包体，以上的验证过程，是开发者将包体提交到App Store之后，由App Store进行验证的，验证通过之后，会使用apple的CA公钥，也就是根证书公钥对包体进行重签，重签后的包体结构以及用户从app store下载包体之后，对包体进行验证的流程如下图所示：

![正式包体的重签](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/app-store-resigning.png?x-oss-process=image/resize,w_800 "正式包体的重签")

![正式包体的安装验证](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/app-store-validation.png?x-oss-process=image/resize,w_800 "正式包体的安装验证")

## 总结

以上就是对iOS包体签名，验证的一个大致认识，其中的具体细节还有很多，但是目前没有精力继续了解以及实际操作，用这篇文章记录下一个大概的认知，之后在工作中听到一些跟包体相关的专业名词时，也不至于一脸懵逼。