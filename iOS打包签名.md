# iOS打包签名

为了保证安装到iOS设备上的app，都是经过苹果官方验证允许的，苹果建立了一套对iOS包体进行签名的机制。

## 签名的原理

为了了解签名的原理，我们需要先认识一下两种常见的加密类型

### 对称加密

对称加密指的是数据的发送方与数据的接收方各自持有**相同**的密钥，数据发送方使用密钥对数据进行加密，数据接受方收到数据后使用相同的密钥对数据进行解密，这种加密方式可以保证数据在传输过程中的安全性，即，截获数据的第三方无法解码出数据，无法篡改数据。但是，这种安全性是建立在密钥不被泄露的情况下，因此需要保证密钥在传输到数据接收者的过程中不被泄露。

### 非对称加密

与对称加密不同，非对称加密数据发送者与数据接受者各自持有不同的密钥，称为私钥与公钥。数据发送者持有私钥，发送数据前，使用私钥对数据进行加密。数据接受者收到数据后，使用公钥进行解密。私钥公钥成对出现，一个私钥有且仅有一个公钥与之对应，私钥保密，公钥则可以被任何人拥有。

看到这里，你也许会问，既然非对称加密的公钥谁都可以拥有，那数据传输的过程中，任何拥有公钥的第三方截取到数据之后不是能把数据看个精光，那还加密个屁啊。没错，确实是这样的，非对称加密理论上只是用来防止数据在传输过程中被篡改，至于数据在传输过程中被其他拥有公钥的第三方偷窥，不是对称加密关心的问题。

但是，单靠非对称加密真的能防止数据被篡改吗，并不能。设想一下这种情况。

1. 数据发送者A在本地生成了一对公钥与私钥，并把公钥发送给数据接收者B
2. 非数据接受者的第三方C拦截到了公钥，C自己在本地生成的一对新的私钥与公钥，并将这个公钥发送给了B，**B错误地将C的公钥当成了A的公钥。**
3. A使用私钥对数据进行加密，并发送给B
4. C对A发送的数据进行拦截，并使用A的公钥进行解密
5. C对解密后的数据进行篡改，并使用自己的私钥对篡改后的数据进行加密发送给了B
6. B收到数据后，使用C的公钥进行解密得到了经过C篡改的数据，**这不就寄了**

为了进一步降低非对称加密数据在传输过程被篡改的可能性，数据签名技术应运而生。

### 数据签名

上文给出的例子中，不难看出，整件事请其实是由一个错误的公钥引起的，如果B能够对自己收到的公钥的有效性进行验证，进而识别出自己收到的公钥并非由A提供的公钥，那相信B也不会用这把公钥继续对收到的信息进行解密。

而数据签名恰恰就是用来干这件事的。数据签名有两个作用，一个是验证公钥的有效性，另一个则是为加密数据生成信息摘要。验证公钥的有效性上文已经大致介绍过了，这个生成信息摘要又是什么呢？

#### 信息摘要

以本文的主角iOS包体ipa为例，一个ipa包体的大小，小的有几十MB，大的动辄几GB，对这么大的数据量进行加密解密，耗时长，效率低。现代人都没什么耐心，有时候一个游戏首包资源太大都可能劝退一大群玩家。信息摘要解决的就是加密信息过大的问题，其是一段对未加密的信息内容进行一个计算所得到的哈希值，具有一下几个特点：

1. 大小固定，不受原本信息大小的影响。
2. 不可逆，由信息摘要无法反推出原信息。
3. 唯一性，不同原数据生成的哈希值绝对不同。

因此，既然不同原数据生成的信息摘要肯定是不同的，那么很自然地，信息摘要就可以用来等效原数据，也就是说，如果摘要没有被篡改，那么原数据肯定也没有被篡改。因为数据接收者可以通过对收到的原数据进行哈希计算，将这个计算的哈希值跟收到的哈希值进行对比，如果一致，则说明收到的原数据没有被篡改，反之，则说明数据被篡改过。

也可以这么理解，有了信息摘要之后，想要篡改数据的第三方，篡改原数据之外，还需要重新生成信息摘要，不能只篡改原数据。因此，对原数据进行加密的问题就变成了对原数据信息摘要进行加密的问题。对信息摘要加密的效率可以比对整段元素据进行加密要快多了。

### 签名证书

在进入签名证书的内容前，我们再重新捋一捋非对称加密数据传输的新过程。

1. 数据发送者A对发送的原数据进行哈希计算，生成原数据的哈希值a（信息摘要）
2. A使用私钥对信息摘要进行加密，将信息摘要与原数据发送给数据接收者B
3. B收到信息摘要与原数据后，使用公钥对信息摘要进行解密，并对收到原数据进行哈希计算，得到一段由自己计算得到的哈希值b
4. B对哈希值a与哈希值b进行对比，若两者相同，则说明收到原数据并没有被篡改。反之，说明原数据被篡改过。

因此，不管是对原数据直接进行加密，还是对信息摘要信息加密，都需要保证数据接收方用来解密的公钥确确实实是数据发送方给的，也就是公钥的有效性（安全性）。人们建立了CA机制来确保公钥的安全性。所谓CA，就是Certificate Authoriy的缩写，即认证凭证，一般都是一些权威机构，比如Apple自身就是一个CA。CA为每个公开密钥的用户发放一个数字证书，