# 正则表达式

## 正则表达式基础知识点

### 1. 元字符

常用元字符

|元字符|说明|
|-----|----|
|.|匹配除了换行符以外的所有字符|
|\w|匹配字母或数字或下划线或汉字的字符|
|\s|匹配任意的空白字符|
|\d|匹配数字|
|\b|匹配单词的开始或结束，***单词通常指由字母，数字跟下划线组成的连续字符序列***|
|^|匹配字符串的开始，***字符串指一段连续的字符序列，可以包含任何字符***|
|$|匹配字符串的结束|
|\W|匹配任意不是字母，数字，下划线，汉字的字符|
|\S|匹配任意不是空白符的字符|
|\D|匹配任意非数字的字符|
|\B|匹配不是单词开头或结束的位置|
|[^x]|匹配除了x以外的任意字符|
|[^aeiou]|匹配除了aeiou这几个字母以外的任意字符|

使用以上元字符，书写一些简单的正则表达式：

1. 匹配有abc开头的字符串: `\babc or ^abc`(abccb)
2. 匹配8位数字的字符串：`^\d\d\d\d\d\d\d\d$`(123456789)
3. 匹配1开头的11位数字的字符串：`^1\d\d\d\d\d\d\d\d\d\d$`

### 2. 重复限定符

正则表达式提供了以下这些元字符来处理重复的元字符

|元字符|说明|
|---|---|
|*|重复零次或多次|
|+|重复一次或多次|
|？|重复零次或一次|
|{n}|重复n次|
|{n,}|重复n次及以上|
|{n,m}|重复n次到m次|

直接看例子，简洁明了

1. 匹配8位数字的字符串：```^\d{8}$```
2. 匹配1开头的11位数字的字符串：```^1\d{10}```
3. 匹配14~18位数字组成的字符串：```^\d{14,18}$```
4. 匹配以a开头，0个或者多个以b结尾的字符串：```^ab*$```(ab(√), abbbbbb(√), axcdb(x))

### 3. 分组

从上面的例子4看出，*限定符是作用在与它左边最近的一个字符，这个时候，如果想要ab同时被作用，应该怎么写呢？

在正则表达式，用小括号()来进行分组，也就是括号中的内容作为一个整体。如果要ab同时被作用，我们可以这么写：

```^(ab)*$``` 表示由零个或多个ab组合重复组成的字符串，例如，ababababc

### 4.转义

正则表达式使用()来进行分组，如果需要在正则表达式匹配'('或者')'，那么，就需要使用转义字符，方法非常简单，在需要转义的字符前加一个'\'就可以了

比如，可以使用```^(\(ab\))+```匹配以(ab)开头的字符串

### 5. 条件或

正则表达式使用符号|来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成时匹配成功，比如:

```^(137|138)\d{8}￥```，可以用来匹配以137或者138开头的11位数字的字符串

### 6. 区间

正则表达式提供一个元字符中括号[]来表示区间条件。

1. 限定0到9，可以写成[0-9]
2. 限定A-Z，可以写成[A-Z]
3. 限定某些数字可以写成[1 3 7]

因此，匹配137或者138开头的11位数字的字符串可以简化为：```^(13[7-8])\d{8}$```

## 正则表达式进阶

### 零宽断言

先解释以下这两个名词：

1. 断言：意思是，正则可以向人类一样断定什么什么，比如"ss1aa2bb3"，正则可以用断言找出aa2后面有bb3，也可以找出aa2前面有ss1
2. 零宽：就是没有宽度，在正则中，断言只匹配位置，不占字符，也就是说，匹配结果不会返回断言本身

直接看例子吧，简单明了。假设我们要抓取csdn里文章的阅读量，通过查看源码可以看到文章的阅读量是这个内容：

```
<span class>"read-count">=阅读数：17</span>
```

其中，我们需要获得‘17’这个变量，注意是获得，就是直接匹配到17这个数字上，可以使用断言来实现。

1. 使用正向先行断言（正前瞻）

   * 语法：(?=pattern)
   * 作用：匹配pattern表达式的前面内容，不返回本身

    用上面阅读量的例子，就是```\d+(?=</span>)```

2. 使用正向后行断言（正后瞻）
   
   * 语法：(?<=pattern)
   * 作用：匹配pattern表达式的后面内容，不返回本身
  
    用上面阅读量的例子，就是```(?<=<span class>"read-count">=阅读数：)\d+```

3. 使用负向先行断言（负后顾）
   
   * 语法：（?!pattern）
   * 作用：匹配非pattern表达式的前面内容，不返回本身
  
幸运的时刻，幸运的人

4. 使用负向后行断言
   
    * 语法：(?<!pattern)
    * 作用：匹配非pattern表达式的后面内容，不返回本身。

### 捕获和非捕获

捕获通常与分组联系在一起，称为“捕获组”，意思是，捕获子表达式的内容，然后把捕获（匹配）的结果保存到一个以数字（序列）或者名称（map）为key的数据结构中，之后可以通过数字或者名称来使用这些匹配结果。

这个感觉就不仅仅只是匹配了，而是包含处理了，如果平常只是VSCode里搜索时使用，那这部分没必要看。

1. 以数字进行保存的捕获组
   * 语法：(exp)

```java
String test = "020-85653333";
String reg="(0\\d{2})-(\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find())
{
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++)
    {
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}

// 输出结果
// 分组的个数有：2
// 第0个分组为：020-85653333
// 第1个分组为：020
// 第2个分组为：85653333
```

2. 以命名进行保存的捕获组

    * 语法：(?<name>exp)
```java
String test = "020-85653333";
String reg="(?<zone>0\\d{2})-(?<number>\\d{8})";
Pattern pattern = Pattern.compile(reg);
Matcher mc= pattern.matcher(test);
if(mc.find())
{
    System.out.println("分组的个数有："+mc.groupCount());
    for(int i=0;i<=mc.groupCount();i++)
    {
        System.out.println("第"+i+"个分组为："+mc.group(i));
    }
}

// 输出结果
// 分组的个数有：2
// 分组名称为:zone,匹配内容为：020
// 分组名称为:number,匹配内容为：85653333
```

3. 懒惰
```
    懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。

    特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。
    
    懒惰量词是在贪婪量词后面加个"?"
```


|元字符|说明|
|---|---|
|*?|重复零次或多次，但尽可能少重复|
|+?|重复一次或多次，但尽可能少重复|
|??|重复零次或一次，但尽可能少重复|
|{n,}？|重复n次及以上，但尽可能少重复|
|{n,m}？|重复n次到m次，但尽可能少重复|